Bobelniceanu Darius-Andrei - 331CC
==================================

Ce am folosit la rezolvarea temei: Linux, FLEX si C++

Cea mai dificila parte mi s-a parut gestionarea corecta a stivei de stari cu functiile yy_push_state si yy_pop_state, cat si realizarea unor expresii regulate eficiente si compacte pentru a parsa automatele si gramaticile primite. Intr-un final am reusit sa fac o implementare modulara, astfel incat tranzitiile intre stari sunt usor de vizualizat, iar extragerea informatiilor dorite se face strict in FLEX, fara a folosit functii de string-uri din C++. De asemenea, si flow-ul programului este gestionat in mare parte de stiva de stari, folosind variabile si conditii doar acolo unde este strict necesar (de exemplu in cod, pentru a verifica daca o tranzitie lipseste dintr-un automat, a trebuit neaparat sa trec prin toate tranzitiile de ar trebui sa le aiba automatul pentru a le verifica existenta). O alta problema care mi s-a parut interesanta a fost detectarea corecta a comentariilor multi-line nested, deoarece un simplu regex nu detecteaza corect comentarii precum "/* /* */ */", oprindu-se la primul "*/". Am rezolvat asta cu o noua stare IN_COMMENT din care se iese abia cand numarul de comentarii deschise este egal cu numarul de comentarii inchise.

Tipurile gramaticilor si automatelor sunt determinate dinamic, in timpul citirii, acolo unde este posibil. Am facut asta verificand la fiecare simbol citit din tranzitii/reguli de productie daca a fost incalcata vreo regula. Pentru regulile de productie am determinat niste reguli prin care pot afla tipul gramaticii in acest mod. In primul rand, GR si GIC pot fi doar daca in partea stanga a regulii se afla un singur neterminal, altfel mai poate fi maxim GDC (ex: "S&S1 -> ..." e suficient ca sa dau downgrade la GDC, indiferent de ce mai e in dreapta). Verificarile din partea dreapta se rezuma la ordinea simbolurilor; cand intalnesc un terminal verific daca inaintea lui a fost concatenat si un neterminal, semn ca avem maxim un GIC. Ultima verificare, dupa ce am citit in totalitate o regula, este ca membrul drept sa fie cel putin de aceeasi marime cu cel din dreapta, in caz contrar avem clar o gramatica nerestrictionata.

M-am folosit 3 structuri de date pentru a pastra in memorie datele necesare dupa ce au fost citite: Variable pentru stocarea variabilelor si a domeniului lor, AutomatonData pentru toate informatiile legate de un automat finit si GrammarData pentru informatiile gramaticilor. Fisierul de input este parsat secvential, si pentru a evita conflicte intre variabilele locale si globale, folosesc un contor pentru a retine cate variabile apartin fiecarui automat/gramatica. La finalul unui automat sau gramatica, acestea sunt eliminate din vector, lasand doar variabilele globale. Pentru gestionarea alfabetului, am tratat special cazurile in care primesc o variabila in loc de un caracter obisnuit, expandand domeniul variabilei si adaugand toate simbolurile in alfabetul automatului/gramaticii. Acelasi rationament l-am aplicat si la tranzitii. La regulile de productie nu a fost insa necesar, deoarece cerinta zicea ca se contorizeaza doar variabila neexpandata.